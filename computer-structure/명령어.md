# 명령어

## 소스코드에서 명령어로
- 소스 코드는 실행되기 전 명령어, 데이터로 변환되어 실행
  - 소스코드: 사람(개발자)를 위한 언어 (고급 언어)
  - 명령어: 컴퓨터를 위한 언어 (저급 언어 -> 기계어, 어셈블리어)

- 고급 언어에서 저급 언어로 변환되는 대표적 방식
  - 컴파일: 소스 코드 전체가 컴파일러(gcc, Visual Studio 등)에 의해 검사, 목적 코드로 변환 (ex) c / c++ / Rust)
  - 인터프리트: 소스 코드 한줄씩 인터프리터에 의해 검사, 목적 코드로 변환
  - 컴파일 언어의 특성과 인터프리트 언어의 특성을 모두 갖춘 언어도 있음

```c
#include <stdio.h>

int main()
{
    int a = 1;
    int b = 2;
    int c = a + b;
    printf("&d\n, c");
    return 0;
}
```
->
```gcc
.LC0:
        .string "&d\n, c"
main:
        push    rbp
        mov     rbp, rsp
        sub     rsp, 16
        mov     DWORD PTR [rbp-4], 1
        mov     DWORD PTR [rbp-8], 2
        mov     edx, DWORD PTR [rbp-4]
        mov     eax, DWORD PTR [rbp-8]
        add     eax, edx
        mov     DWORD PTR [rbp-12], eax
        mov     edi, OFFSET FLAT:.LC0
        mov     eax, 0
        call    printf
        mov     eax, 0
        leave
        ret
```

## 명령어의 구조

`무엇을 대상`으로 `무엇을 수행`하라 -> `오퍼랜드`로 `연산코드`를 수행하라
- 오퍼랜드(operand): 명령어를 수행할 대상 (대상이 직접 명시되기도 하고 대상의 위치가 명시되기도 함)
- 연산 코드(op-code): 오퍼랜드로 수행할 동작

## 명령어 유형

- 데이터 전송
- 산술/논리 연산
- 제어 흐름 변경
- 입출력 제어

## 주소 지정

명령어의 길이가 한정적이기 때문에 데이터 대상 자체가 아닌 대상의 위치인 주소를 오퍼랜드로 하기도 함

- 유효 주소: 연산 코드에 사용할 데이터가 저장된 위치, 즉 연산의 대사이 되는 데이터가 저장된 위치
- 주소 지정: 유효 주소를 찾는 방법

### 즉시 주소 지정

- 연산에 사용할 데이터를 오퍼랜드 필드에 직접 명시
- 가장 빠른 주소 지정
- 데이터 크기에 제한

### 직접 주소 지정

- 오퍼랜드 필드에 유효 주소 명시
- 오퍼랜드 필드로 표현 가능한 메모리 주소 크기에 제한
- CPU가 레지스터에 접근하는 속도보다 메모리에 접근하는 속도가 더 느리므로 그 시간만큼 손해를 볼 수 있음

### 간접 주소 지정

- 오퍼랜드 필드에 유효 주소의 주소 명시
- 유효 주소 크기에 제한은 없으나, 속도가 비교적 느림

### 레지스터 주소 지정

- 연산에 사용할 데이터를 저장한 레지스터를 오퍼랜드 필드에 직접 명시
- 레지스터에 접근하기 때문에 메모리에 접근하는 방식보다 빠름

### 레지스터 간접 주소 지정

- 연산에 사용할 데이터를 메모리에 저장
- 유효 주소를 저장한 레지스터를 오퍼랜드 필드에 명시
- 메모리 접근은 한 번
